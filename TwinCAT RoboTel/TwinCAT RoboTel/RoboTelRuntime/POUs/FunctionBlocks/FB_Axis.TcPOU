<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.0">
  <POU Name="FB_Axis" Id="{18cf88d0-9c12-4f7c-90a6-943ec400ede8}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Axis
VAR_INPUT
	// Enable Axis ("Achsfreigabe")
	bPowerEnable: 		BOOL;
	// enable forward motion
	bEnable_Positive:	BOOL := TRUE;
	//enable backward motion
	bEnable_Negative:	BOOL := TRUE;
	//override controls
	fPowerOverride: 	LREAL := 100;
	// reset axis error
	bReset:				BOOL;
	
	// execute axis movement
	bMoveAbsExec: 		BOOL;
	// axis target position
	fMoveAbsPos: 		LREAL;
	// axis velocity
	fMoveAbsVelo: 		LREAL;
	// lock axis with error
	bStop:			 	BOOL;
	// halt axis
	bHalt:				BOOL;
END_VAR
VAR_OUTPUT
	// power status of the axis
	bPowerStatus: 		BOOL;
	// reset done
	bResetDone: 		BOOL;
	
	// axis has reached target
	bMoveAbsDone: 		BOOL;
	// axis is busy moving
	bMoveAbsBusy: 		BOOL;
	// axis error on movement
	bMoveAbsErr: 		BOOL;
	

	// axis error
	bAxError: 			BOOL;
	// axis error id
	nAxErrId: 			DWORD;
	// current velocity
	fActVelo: 			LREAL;
	// current position
	fActPos: 			LREAL;
	
END_VAR
VAR
	
	// Baustein Reglerfreigabe
	fbMcPower:	MC_Power;
	
	StfbMcPowerOut: ST_McOutputs;
	
	// Baustein Reset
	
	fbMCReset:	MC_Reset;
	StfbMcResetOut: ST_McOutputs;
	
	


	(*===========================*)
	(*Instanz von MC_Move Absolute*)
	fbMoveAbsolute: MC_MoveAbsolute;
	StfbMcMoveAbsolut: ST_McOutputs;
	

	(* MC_Stop *)
	fbMcStop : MC_Stop;
	st_fbMcStopOut: ST_McOutputs;
	
	fbMcHalt:	MC_Halt;
//	nstate: INT;
//	fb_RTrig1: R_TRIG;
	MC_ReadActualPosition: MC_ReadActualPosition;

END_VAR
VAR_IN_OUT
	stAxis: AXIS_REF;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*============NICHT VERGESSEN: =============*)
(* ACTION ReadStatus aktualisiert Status Struktur in Axis_REF *)
stAxis.ReadStatus();
(*Zyklische Abfrage von Achszuständen*)

bAxError :=	stAxis.Status.Error;
nAxErrId :=	stAxis.Status.ErrorID;

fActVelo :=	stAxis.NcToPlc.ActVelo;
fActPos  :=	stAxis.NcToPlc.ActPos;

fbMcPower(
	Axis			:= stAxis, 
	Enable			:= bPowerEnable, 
	Enable_Positive	:= bEnable_Positive, 
	Enable_Negative	:= bEnable_Negative, 
	Override		:= fPowerOverride, 
	BufferMode		:= , 
	Options			:= , 
	Status			=> StfbMcPowerOut.Done, 
	Busy			=> StfbMcPowerOut.Busy, 
	Active			=> StfbMcPowerOut.Active, 
	Error			=> StfbMcPowerOut.Error, 
	ErrorID			=> StfbMcPowerOut.ErrorID);	

(*FB Output*)

bPowerStatus:= fbMcPower.Status;


(* Achse reset: :*)
(*	quittieren eines Achsfehlers
	Schleppabstand auf 0
	Auftrag abbrechen
*)
	
fbMCReset(
	Axis	:= stAxis, 
	Execute	:= bReset, 
	Done	=> StfbMcResetOut.Done, 
	Busy	=> StfbMcResetOut.Busy, 
	Error	=> StfbMcResetOut.Error, 
	ErrorID	=> StfbMcResetOut.ErrorID);

bResetDone := fbMCReset.Done;		
	(*===========Motion: Achsstarts================================*)
	
//Einzelfahrbefehl
fbMoveAbsolute(
	Axis			:= stAxis, 
	Execute			:= bMoveAbsExec, 
	Position		:= fMoveAbsPos, 
	Velocity		:= fMoveAbsVelo, 
	Acceleration	:= 0, // 0 heisst default aus SystemManager "Dynamik" 
	Deceleration	:= 0, 
	Jerk			:= 0, 
	BufferMode		:= MC_BlendingNext, 
	Options			:= , 
	Done			=> StfbMcMoveAbsolut.Done, 
	Busy			=> StfbMcMoveAbsolut.Busy, 
	Active			=> StfbMcMoveAbsolut.Active, 
	CommandAborted	=> StfbMcMoveAbsolut.CommandAborted, 
	Error			=> StfbMcMoveAbsolut.Error, 
	ErrorID			=> StfbMcMoveAbsolut.ErrorID);

bMoveAbsDone := fbMoveAbsolute.Done;
bMoveAbsBusy := fbMoveAbsolute.Busy;
bMoveAbsErr := fbMoveAbsolute.Error;

(*Achse STOP
Besonderheit: Nach Stop ist die Achse solange gesperrt bis Execute 0 ist
Ist das nicht gewünscht kann MC:HALT genutzt werden. Dieser ist nur Flankengesteuert
*)
	
fbMcStop(
	Axis			:= stAxis, 
	Execute			:= bStop, 
	Deceleration	:= 0, 
	Jerk			:= 0, 
	Options			:= , 
	Done			=> st_fbMcStopOut.Done, 
	Busy			=> st_fbMcStopOut.Busy, 
	Active			=> st_fbMcStopOut.Active, 
	CommandAborted	=> st_fbMcStopOut.CommandAborted, 
	Error			=> st_fbMcStopOut.Error, 
	ErrorID			=> st_fbMcStopOut.ErrorID );

fbMcHalt(
	Axis			:= stAxis, 
	Execute			:= bHalt, 
	Deceleration	:= 0, 
	Jerk			:= 0,
	BufferMode 		:= MC_Aborting);]]></ST>
    </Implementation>
    <LineIds Name="FB_Axis">
      <LineId Id="3" Count="9" />
      <LineId Id="14" Count="3" />
      <LineId Id="170" Count="1" />
      <LineId Id="20" Count="10" />
      <LineId Id="255" Count="0" />
      <LineId Id="32" Count="14" />
      <LineId Id="256" Count="0" />
      <LineId Id="47" Count="19" />
      <LineId Id="257" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="259" Count="0" />
      <LineId Id="258" Count="0" />
      <LineId Id="260" Count="0" />
      <LineId Id="68" Count="17" />
      <LineId Id="360" Count="0" />
      <LineId Id="365" Count="0" />
      <LineId Id="361" Count="3" />
    </LineIds>
  </POU>
</TcPlcObject>